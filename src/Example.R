library(here)
source(here('src', 'DataGeneration3.R'))
source(here('src', 'Functions3.R'))
source(here('src', 'Tuning.R'))

################################

# This is an example R script. #

################################

## Some parameter setting for data generation:
## (You can skip this part if not interested in synthetic data)

L = 5     # number of source sites
q = 4     # dim of low-d A = q+1
p = 195   # rest dim of covariate X. Total dim of X is (1+q+p).
ptemp = 6

Nlist = rep(500,5)      # Source sample size of X. 
nlist = rep(300,5)      # Source sample size of Y.
n0 = 500                # Target sample size of X0.
# You can set these sizes larger in real simulation.

mixture = c(0.5,0,0.5,0,0)    # How target is mixed by sources. Here 1/2 from site 1 and 1/2 from site 3.
trues = 0.2                  # Probability that target use another mixture delta.
delta = c(0,0.5,0,0.5,0)

# Each covariate X = (1,A,W). First few elements of W is correlated with A, while the rest is noise.
MU_A = 0.5 * matrix(c(-2,0,1,0,
                      0,-1,2,1,
                      -1,2,0,1,
                      1,1,-1,2,
                      2,1,1,2),nrow=L,ncol=q,byrow=TRUE) # Each row is the mean of A_l

# True setting of BETA. Y = X %*% BETA + eps.
BETA =     1  *  matrix(c(0,4,4,3,-3,  0.5,-0.2,0,0,1,0,
                          -3,3,-1,3,-3, 0,0.5,-0.2,0,0,1,
                          -3,-3,0,-3,-3,  0,0,0.2,-0.5,0,1,
                          -6,6,6,6,-6,  1,0,0,0.2,-0.5,0,
                          -3,3,0,0,1, 0,0,0,1,0.2,-0.5),nrow=L,ncol=ptemp+q+1,byrow=TRUE)



################################

## Now we conduct the example simulation.

Data = Generate_Simulation_Data(L,p,q,Nlist,nlist,n0,mixture,delta,trues,MU_A,BETA,ptemp,eps_A=1,eps_W=0.01)
summary(Data)

################################
#  Nlist[l] = N_l, nlist[l] = n_l
#  Xlist: a list of source covariates. Xlist[[l]] is N_l * (1+q+p) matrix, source l covariates.
#  Xtrainlist: equal size to Xlist. Used for sample splitting.
#  Ylist: a list of labels/outcomes. Ylist[[l]] is n_l vector. Ylist[[l]] is calculated by
#         the first n_l rows of Xlist[[l]].
#  X0: target covariates. A n_0 * (1+q+p) matrix.
#  Y0: target labels/outcomes. A n_0-vector. We can use part of it or all of it.
#  S0: Surrogate vector.
#  Assigns(_train): n0-vector, tells us which site the i-th target data (X0[i],Y0[i]) is assigned to.
#  
#  ATTENTION: splitted data (Xlist,Xtrainlist) should be of equal size!
################################

## Given that we have X is 1+p+q (previous q=4) = 200, we can do partition for A:
## Setting 1: Low-dim A, use penalty = FALSE
q = 4

## Setting 2: High-dim A dim = 150, penalty = TRUE
q = 149

## You can try both 2 settings. (q+1) is the dimension of A!

################################

smax = 0.25

result = get_REMIX_beta(Data$Xlist,Data$Xtrainlist,Data$Ylist,Data$Ytrainlist,Data$X0,Data$X0train,nlist,q,smax,
                        penalty = TRUE,alpha = 0.5,rho_pseudo = 'pool', dr_type = "rf",normalize = FALSE)

# change penalty to correct status you want. 
# alpha is the parameter in elastic net.
# rho_pseudo \in {'max','pool','NA'}
# dr_type = 'logit' means using logistic regression (elastic net) to fit density ratio model.
# dr_type can be chosen from: 'rf','logit','XGB','nnet'.
# normalize means we truncate and normalize the density ratio. Recommendation is FALSE.

# It is normal for get_REMIX_beta to take 10 mins to run.

summary(result)

as.vector(result$beta_star)   # This is our beta_REMIX.

result$rho
dra = result$DR_dP0bydPl # This is the DR: P_target(x)/P_source(x), each row is for each source site.
rowMeans(1/dra)
# Ideally, the 1st and 3rd element should be close to 1, because they have big overlap with target.
# The rest of mean density ratios may be farther from 1 due to less overlap.


## Implement parameter tuning. We need to put all beta(smax) in a matrix.
smax_array = seq(0.1,0.5,0.1)     # smax array to be tuned over.
nsmax = 5
beta_array = matrix(0,nrow = nsmax, ncol = q+1)     # beta(smax), we put them in the corresponding rows.
for(i in 1:nsmax){
  result = get_REMIX_beta(Data$Xlist,Data$Xtrainlist,Data$Ylist,Data$Ytrainlist,Data$X0,Data$X0train,nlist,q,smax_array[i],
                          penalty = TRUE,alpha = 0.5,rho_pseudo = TRUE, dr_type = "logit")
  beta_array[i,] = result$beta_star
  cat("smax =",smax_array[i],'\n')
}

# 1. use Y. For example we only use 50 of Y here. Note that Y0 is generated by X0.
nn = 50
ty = tuning_Y(Data$X0[1:nn,],Data$Y0[1:nn],q,beta_array,smax_array)
ty
# 2. use surrogate.
ts = tuning_surrogate(Data$X0,Data$S0,q,beta_array,smax_array)
ts


## Calculate Benchmarks. We use true underlying target Y here.
smax = ty$best_smax # Tuned smax
result = get_REMIX_beta(Data$Xlist,Data$Xtrainlist,Data$Ylist,Data$Ytrainlist,Data$X0,Data$X0train,nlist,q,smax,
                        penalty = TRUE,alpha = 0.5,rho_pseudo = TRUE, dr_type = "logit")
benchmarks(X0,Y0,q,result$beta_star,result$beta_MI,result$rho,result$beta_RAP,result$DoublyR)







##############################################
##############################################
# Below are some internal technical tests. You can ignore them.

q = 149
smax = 0.05

### New test

res1 = get_REMIX_beta(Data$Xlist,Data$Xtrainlist,Data$Ylist,Data$Ytrainlist,Data$X0,Data$X0train,
                      nlist,q,smax,penalty = TRUE,alpha = 0.5,rho_pseudo = FALSE, dr_type = "rf")
res1$rho
rowMeans(1/res1$DR_dP0bydPl)

res2 = get_REMIX_beta(Data$Xlist,Data$Xtrainlist,Data$Ylist,Data$Ytrainlist,Data$X0,Data$X0train,
                      nlist,q,smax,penalty = TRUE,alpha = 0.5,rho_pseudo = FALSE, dr_type = "nnet")
res2$rho
rowMeans(1/res2$DR_dP0bydPl)


res3 = get_REMIX_beta(Data$Xlist,Data$Xtrainlist,Data$Ylist,Data$Ytrainlist,Data$X0,Data$X0train,
                      nlist,q,smax,penalty = TRUE,alpha = 0.5,rho_pseudo = FALSE, dr_type = "XGB")
res3$rho
rowMeans(1/res3$DR_dP0bydPl)


## test data
newdelta = c(0.2,0.2,0,0.4,0.2)
news = 0.5
datt = Generate_Simulation_Data(L,p,q,Nlist,nlist,n0,mixture,newdelta,news,MU_A,BETA,ptemp)
benchmarks(datt$X0,datt$Y0,q,result$beta_star,result$beta_MI,result$rho,result$beta_RAP,result$DoublyR)

## internal functions

modellist = dr_estimation_RF(Xtrainlist,X0train)
dr = dratioX0(modellist,X0train,L)
drlist = list()
for(l in 1:L){
  drlist[[l]] = dratioX0(modellist,Xtrainlist[[l]],L)
}
rho = mulcvxr(L,dr)
betalist = lasso_imputation(Xtrainlist,Ytrainlist,nlist)
post = posterior(rho,dr,Nlist,n0)
postlist = list()
for(l in 1:L){
  postlist[[l]] = posterior(rho,drlist[[l]],Nlist,Nlist[[l]])
}

PQ = PQCalculation(X0,Xlist,Ylist,X0train,Xtrainlist,Ytrainlist,nlist,post,postlist,
                   drlist,betalist,q,penalty = TRUE,alpha = 0.5)
PQ$P
PQ$Q

dts_star = opt_s_delta(P,Q,Sigma0,smax)
s = dts_star[L+1]
opt.beta = (1-s)*P + s* Q %*% dts_star[1:L]
# cat("\n delta* is",dts_star[1:L]," and s* is",s)

dt_MI = opt_delta(P,Q,Sigma0,1)
beta_MI = Q %*% dt_MI
# cat("\n delta_MI is",dt_MI,"\n")

##############################################
##############################################
# Example: Conditional on A (condA) Model

## Generate data with mixture conditional on A
source(here('src', 'DataGen_CondA.R'))

L = 5
q = 4
p = 195
ptemp = 6

Nlist = rep(500, 5)
nlist = rep(300, 5)
n0 = 500

mixture = c(0.5, 0, 0.5, 0, 0)  # Target mixture weights
s = 0.2                          # Perturbation probability
delta = c(0, 0.5, 0, 0.5, 0)    # Perturbation mixture

BETA = 1 * matrix(c(0,4,4,3,-3,  0.5,-0.2,0,0,1,0,
                    -3,3,-1,3,-3, 0,0.5,-0.2,0,0,1,
                    -3,-3,0,-3,-3,  0,0,0.2,-0.5,0,1,
                    -6,6,6,6,-6,  1,0,0,0.2,-0.5,0,
                    -3,3,0,0,1, 0,0,0,1,0.2,-0.5),
                  nrow=L, ncol=ptemp+q+1, byrow=TRUE)

# Generate data conditional on A
Data_condA = Generate_Simulation_Data_CondA(L, p, q, Nlist, nlist, n0, mixture,
                                             delta, s, BETA, ptemp)

# Run DORM with condA=TRUE to use conditional density ratio
smax = 0.25
result_condA = get_DORM_beta(Data_condA$Xlist, Data_condA$Xtrainlist, 
                             Data_condA$Ylist, Data_condA$Ytrainlist,
                             Data_condA$X0, Data_condA$X0train, nlist, q, smax,
                             penalty = FALSE, alpha = 0.5, rho_pseudo = 'pool', 
                             dr_type = "rf", normalize = FALSE, condA = TRUE)

cat("\n=== CondA Model Results ===\n")
cat("Estimated rho:", result_condA$rho, "\n")
cat("Beta_DORM (first 5 coefs):", result_condA$beta_star[1:5], "\n")

# Compare with standard model (condA=FALSE)
result_standard = get_DORM_beta(Data_condA$Xlist, Data_condA$Xtrainlist, 
                                Data_condA$Ylist, Data_condA$Ytrainlist,
                                Data_condA$X0, Data_condA$X0train, nlist, q, smax,
                                penalty = FALSE, alpha = 0.5, rho_pseudo = 'pool', 
                                dr_type = "rf", normalize = FALSE, condA = FALSE)

cat("\n=== Standard Model Results ===\n")
cat("Estimated rho:", result_standard$rho, "\n")
cat("Beta_DORM (first 5 coefs):", result_standard$beta_star[1:5], "\n")








